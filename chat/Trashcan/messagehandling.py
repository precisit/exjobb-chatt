import pikaimport sysimport routerimport loggingimport uuidfrom pika.adapters.tornado_connection import TornadoConnection#!/usr/bin/python -tt# messagehandling via pika# resultClient = # resultServer = routing_key = 'routing_key'routing_key_server = 'routing_key_server'clientQueue = uuid.uuid4()serverQueue = uuid.uuid4()class NullHandler(logging.Handler):    def emit(self, record):        passlogger = logging.getLogger('pika')logger.setLevel(logging.WARN)logger.addHandler(NullHandler())class PikaClient(object):    def __init__(self,io_loop):        # giving unique queue for each consumer        # self.queue_name = "queue-%s" % (id(self),)        # create a new instance passing the io_loop used to connect to RabbitMQ        self.io_loop = io_loop        self.connected = False        self.connecting = False        self.connection = None        self.channel = None         self.event_listeners = set([])    def connect(self):        if self.connecting:            print('PikaClient: Already connecting to RabbitMQ')            return         print('PikaClient: Connecting to RabbitMQ')        self.connecting = True         #cred = pika.PlainCredentials('guest', 'guest')        param = pika.ConnectionParameters(            host='localhost',        #    port=3000,        #   virtual_host='/echoWebSocket',        #   credentials=cred        )         self.connection = TornadoConnection(            param,            on_open_callback=self.on_connected,        #    stop_ioloop_on_close=False        )        # This will close the ioloop        self.connection.add_on_close_callback(self.on_closed)     def on_connected(self, connection):        # Called when we are fully connected to RabbitMQ        print('PikaClient: connected to RabbitMQ on localhost')        self.connected = True        self.connection = connection        # Open a channel        self.connection.channel(self.on_channel_open)     def on_channel_open(self, channel):        # Called when our channel has opened        print('PikaClient: Channel open, Declaring exchange')        self.channel = channel        # declare exchanges        channel.exchange_declare(            exchange = 'tornado-chat',             type = 'direct'        )        # declare queues        print('PikaClient: Exchange Declared, Declaring Queue')        # client queue        channel.queue_declare(self.on_queue_declared_client, queue = clientQueue.hex, exclusive = True, auto_delete = True)        # server queue        channel.queue_declare(self.on_queue_declared_server, queue = serverQueue.hex, exclusive = True, auto_delete = True)    def on_queue_declared_client(self,queue):        self.clientQueue = queue.method.queue        # binding queue        #self.channel.queue_bind(        #    exchange = 'tornado-chat',        #    queue = self.clientQueue        #)        # client queue should use callback, when receiving a message        self.channel.basic_consume(            self.on_client_message,            queue = self.clientQueue,            no_ack = True        )    def bind_client_queue(self, routing_key):        self.channel.queue_bind(            self.on_queue_bound,            exchange = 'tornado-chat',            queue = self.clientQueue,            routing_key = routing_key,            )    def on_queue_declared_server(self,queue):        self.serverQueue = queue.method.queue        # binding queue        # server queue should use callback, when receiving a message        self.channel.basic_consume(            self.on_server_message,            queue = self.serverQueue,            no_ack = True        )        self.channel.queue_bind(            self.on_queue_bound,            exchange = 'tornado-chat',            queue = self.serverQueue,            routing_key = routing_key_server        )    # def on_exchange_declared(self,frame):    #   print('PikaClient: Exchange Declared, Declaring Queue')    #   self.channel.queue_declare(    #        auto_delete = True,    #       queue = self.queue_name,    #       durable = False,    #       exclusive = True,    #       callback = self.on_queue_declared    #    )    # def on_queue_declared(self,frame):    #   print('PikaClient: Queue Declared, Binding Queue')    #   self.channel.queue_bind(    #         exchange = 'tornado',    #       queue = self.queue_name,    #       routing_key = 'tornado.*',    #       callback = self.on_queue_bound    #     )    # Bind the queueto the specified exchange     def on_queue_bound(self,frame):        pass    def unbind_queue(self, routing_key):        self.channel.queue_unbind(        self.on_queue_bound,        exchange = 'tornado-chat',        queue = self.clientQueue,        routing_key = routing_key        )    def on_queue_unbound(self, frame):        pass    def send_client_message(self,routing_key,message):        #print message        #print routing_key        self.channel.basic_publish(            exchange = 'tornado-chat',            routing_key = routing_key,            body = message            )        print "dealing with message"    def send_server_message(self,routing_key,message):            self.channel.basic_publish(            exchange = 'tornado-chat',            routing_key = routing_key_server,            body = message            )     def on_closed(self, connection):        print('PikaClient: rabbit connection closed')        self.io_loop.stop()     # on messages from client    def on_client_message(self, channel, method, header, body):    #    print('PikaClient: message received: %s' % body)    #    self.notify_listeners(event_factory(body))        print "more dealing"        router.processClientMessage(method.routing_key, body)    def on_server_message(self, channel, method, header, body):        router.processServerMessage(method.routing_key, body)     def notify_listeners(self, event_obj):        # here we assume the message the sourcing app        # post to the message queue is in JSON format        event_json = json.dumps(event_obj)         for listener in self.event_listeners:            listener.write_message(event_json)            print('PikaClient: notified %s' % repr(listener))     def add_event_listener(self, listener):        self.event_listeners.add(listener)        print('PikaClient: listener %s added' % repr(listener))     def remove_event_listener(self, listener):        try:            self.event_listeners.remove(listener)            print('PikaClient: listener %s removed' % repr(listener))        except KeyError:            pass