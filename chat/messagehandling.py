import pikaimport sysimport routerimport loggingfrom pika.adapters.tornado_connection import TornadoConnection#!/usr/bin/python -tt# messagehandling via pika# Unhandled exception handlerclass BaseHandler(tornado.web.RequestHandler):    def _handle_request_exception(self, e):        logging.error('error')class NullHandler(logging.Handler):    def emit(self, record):        passlogger = logging.getLogger('pika')logger.setLevel(logging.WARN)logger.addHandler(NullHandler())class PikaClient(object):    def __init__(self,io_loop):        # giving unique queue for each consumer        # self.queue_name = "queue-%s" % (id(self),)        # create a new instance passing the io_loop used to connect to RabbitMQ        self.io_loop = io_loop        self.connected = False        self.connecting = False        self.connection = None        self.channel = None         self.event_listeners = set([])    def connect(self):        if self.connecting:            print('PikaClient: Already connecting to RabbitMQ')            return         print('PikaClient: Connecting to RabbitMQ')        self.connecting = True         # cred = pika.PlainCredentials('guest', 'guest')        param = pika.ConnectionParameters(            host='localhost',        #    port=5672,        #    virtual_host='/',        #    credentials=cred        )         self.connection = TornadoConnection(            param,            on_open_callback=self.on_connected        )        # This will close the ioloop        self.connection.add_on_close_callback(self.on_closed)     def on_connected(self, connection):        # Called when we are fully connected to RabbitMQ        print('PikaClient: connected to RabbitMQ on localhost: 5672')        self.connected = True        self.connection = connection        # Open a channel        self.connection.channel(self.on_channel_open)     def on_channel_open(self, channel):        # Called when our channel has opened        print('PikaClient: Channel open, Declaring exchange')        self.channel = channel        # declare exchanges        channel.exchange_declare(            exchange = 'tornado-chat',             type = 'direct'        )        # declare queues        print('PikaClient: Exchange Declared, Declaring Queue')        # client queue        channels.queue_declare(self.on_queue_declared_client, queue = clientQueue, exclusive = True, auto_delete = True)        # server queue        channels.queue_declare(self.on_queue_declared_server, queue = serverQueue, exclusive = True, auto_delete = True)    def on_queue_declared_client(self,queue):        self.clientQueue = result.method.queue        # binding queue        self.channel.queue_bind(            exchange = 'tornado-chat',            queue = self.clientQueue        )        # client queue should use callback, when receiving a message        self.channel.basic_consume(            self.on_message_client,            queue = self.clientQueue,            routing_key = client_routing_key        )    def on_queue_declared_server(self,queue):        self.serverQueue = result.method.queue        # binding queue        self.channel.queue_bind(            exchange = 'tornado-chat',            queue = self.serverQueue        )        # server queue should use callback, when receiving a message        self.channel.basic_consume(            self.on_message_server,            queue = self.serverQueue,            routing_key = server_routing_key        )    # def on_exchange_declared(self,frame):    #   print('PikaClient: Exchange Declared, Declaring Queue')    #   self.channel.queue_declare(    #        auto_delete = True,    #       queue = self.queue_name,    #       durable = False,    #       exclusive = True,    #       callback = self.on_queue_declared    #    )    # def on_queue_declared(self,frame):    #   print('PikaClient: Queue Declared, Binding Queue')    #   self.channel.queue_bind(    #         exchange = 'tornado',    #       queue = self.queue_name,    #       routing_key = 'tornado.*',    #       callback = self.on_queue_bound    #     ) # Binding to events # By using this ou can listen for an event on all the channels that you are currently subscribed to.    def bind_client_queue(self, routing_key):        self.channel.queue_bind(            self.on_bind_ok,            exchange = rabbitmq_exchange,            queue = self.client_queue,            routing_key = routing_key        )# Removing a binding to an event on a channel    def unbind_client_queue(self, routing_key):        self.channel.queue_unbind(            self.on_bind_ok,            exchange = rabbitmq_exchange,            queue = self.client_queue,            routing_key = routing_key        )    # Bind the queueto the specified exchange     def on_queue_bound(self,frame):        print('PikaClient: Message receive, delivery tag #%i' % method.delivery_tag)     def on_closed(self, connection):        print('PikaClient: rabbit connection closed')        self.io_loop.stop()     # on messages from client    def on_message(self, channel, method, header, body):    #    print('PikaClient: message received: %s' % body)    #    self.notify_listeners(event_factory(body))        router.handleMessage(method.routing_key, data)    def send_message(self,routing_key,message):        self.channel.basic_publish(            exchange = 'tornado-chat',            routing_key = routing_key,            body = message            )     def notify_listeners(self, event_obj):        # here we assume the message the sourcing app        # post to the message queue is in JSON format        event_json = json.dumps(event_obj)         for listener in self.event_listeners:            listener.write_message(event_json)            print('PikaClient: notified %s' % repr(listener))     def add_event_listener(self, listener):        self.event_listeners.add(listener)        print('PikaClient: listener %s added' % repr(listener))     def remove_event_listener(self, listener):        try:            self.event_listeners.remove(listener)            print('PikaClient: listener %s removed' % repr(listener))        except KeyError:            pass